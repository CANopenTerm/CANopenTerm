# Subprojects

## CANvenient

!> CANvenient is an abstraction layer for multiple CAN APIs on Windows,
similar to libsocketcan on Linux.  It is currently under development
and not yet released.

## codb2json

### Introduction

`codb2json` is a command-line utility designed to convert CANopen Profile
data base (codb) files to JSON format.  The idea is to provide a more modern
and easy-to-process file format that can be used to check the conformity of
a CANopen CC interface using [CANopenTerm](https://canopenterm.de).

### Description

In order to test if the CANopen CC interface of a device is conform to
CANopen application layer and communication profile (CiA 301), CiA
consortium has developed the
[CANopen CC conformance testing tool](https://www.can-cia.org/services/canopen-conformance-test-tool).

As this tool is primarily a proprietary Windows tool and there are no
alternatives on the market, we would like to extend
[CANopenTerm](https://canopenterm.de) with a similar feature.

To check the conformity of a CANopen CC interface, the CiA tool uses
the so-called CANopen Profile data base (codb) format. This format is
not very well documented, antiquated and somewhat difficult to process.

That's why we developed a converter that generates the same information
in JSON format; a robust, easy to process and widely accepted file
format.

### Installation

To install or build the `codb2json` tool, follow these steps:

1. Clone the repository:
    
```bash
git clone https://github.com/CANopenTerm/codb2json.git
cd codb2json
```

2. Build the project using CMake:

```bash
mkdir build
cmake -S . -B build
cmake --build build
```

### Usage

The `codb2json` tool is a command-line utility that converts a
CANopen Profile data base (codb) file to JSON format.  It takes
the path to the CODB file as input and generates a corresponding
JSON file as output:

```bash
./codb2json v301.codb
```

The resulting JSON file will have the same name as the input
file, but with the `.json` extension.

### File Format Specification

The JSON format generated by `codb2json` follows a structured schema to represent CANopen Profile data base (codb) files. Below is the detailed specification of the JSON format:

<!-- tabs:start -->
<!-- tab: Root Structure -->
The root of the JSON file is an array of objects, each representing a CANopen object dictionary entry.

```json
[
  {
    "id": "1000",
    "index": 4096,
    "sub_indices": […],
    "code": {…},
    "desc": "Device Type",
    "kind": 0
  }, …
]
```

<!-- tab: Object Dictionary Entry -->
Each object dictionary entry contains the following fields:

- `id` (string): The hexadecimal identifier of the object, main index.
- `index` (integer): The decimal index of the object.
- `sub_indices` (array): An array of sub-index objects.
- `code` (object): An object representing the object code attributes.
- `desc` (string): A description of the object.
- `kind` (integer): The kind of the object, one of the following:
    - `0`: OPTIONAL
    - `1`: MANDATORY
    - `2`: CONDITIONAL

<!-- tab: Sub-Index Object -->
Each sub-index object contains the following fields:

- `index` (integer): The sub-index number.
- `desc` (string): A description of the sub-index.
- `kind` (integer): The kind of the sub-index, one of the following:
    - `0`: OPTIONAL
    - `1`: MANDATORY
    - `2`: CONDITIONAL
- `data_type` (object): An object representing the data type attributes.
- `access_type` (object): An object representing the access type attributes.

<!-- tab: Code Object -->
The code object contains the following fields:

- `type` (integer): The type of the code.
- `attr` (integer): The attribute of the code.
- `lower` (integer): The lower bound of the code.
- `upper` (integer): The upper bound of the code.

<!-- tab: Data Type Object -->
The data type object contains the following fields:

- `type` (integer): The type of the data, one of the following:
    - `0`: DOMAIN,
    - `1`: DEFTYPE,
    - `2`: DEFSTRUCT,
    - `3`: VAR,
    - `4`: ARRAY,
    - `5`: RECORD
- `attr` (integer): The attribute of the data.
- `lower` (integer): The lower bound of the data.
- `upper` (integer): The upper bound of the data.

<!-- tab: Access Type Object -->
The access type object contains the following fields:

- `type` (integer): The type of the access.
- `attr` (integer): The attribute of the access.
- `lower` (integer): The lower bound of the access.
- `upper` (integer): The upper bound of the access.
<!-- tabs:end -->

#### Example

Below is an example of a JSON file generated by `codb2json`:

<!-- tabs:start -->
<!-- tab:Input CODB file -->
```plaintext
1000::Device Type:mandatory::VAR:m:UNSIGNED32:m:ro:d[const,ro]::n::n:::::::n:m

$1001=1001

1003::Predefined Error Field:optional::ARRAY:m::m::m:2:m:255:m::m::m::m::m
1003:00:Number of Errors:optional::VAR:m:UNSIGNED8:m:rw:d[rw,ro]::n::n:::::0:m:n:m
1003:01:Standard Error Field:optional::VAR:m:UNSIGNED32:m:ro:m::n::n::::d:0:m:n:m
```
<!-- tab:Output JSON file -->
```json
[
    {
        "id": "1000",
        "index": 4096,
        "sub_indices": [
            {
                "index": 0,
                "desc": "Device Type",
                "kind": 0,
                "data_type": {
                    "type": 9,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                },
                "access_type": {
                    "type": 1,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                }
            }
        ],
        "code": {
            "type": 3,
            "attr": 1,
            "lower": 0,
            "upper": 0
        },
        "desc": "Device Type",
        "kind": 0
    },
    {
        "id": "1001",
        "index": 4097,
        "sub_indices": [
            {
                "index": 0,
                "desc": "Device Type",
                "kind": 0,
                "data_type": {
                    "type": 9,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                },
                "access_type": {
                    "type": 1,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                }
            }
        ],
        "code": {
            "type": 3,
            "attr": 1,
            "lower": 0,
            "upper": 0
        },
        "desc": "Device Type",
        "kind": 0
    },
    {
        "id": "1003",
        "index": 4099,
        "sub_indices": [
            {
                "index": 0,
                "desc": "Number of Errors",
                "kind": 1,
                "data_type": {
                    "type": 3,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                },
                "access_type": {
                    "type": 3,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                }
            },
            {
                "index": 1,
                "desc": "Standard Error Field",
                "kind": 1,
                "data_type": {
                    "type": 9,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                },
                "access_type": {
                    "type": 1,
                    "attr": 0,
                    "lower": 0,
                    "upper": 0
                }
            }
        ],
        "code": {
            "type": 4,
            "attr": 1,
            "lower": 0,
            "upper": 0
        },
        "desc": "Predefined Error Field",
        "kind": 1
    }
]
```
<!-- tabs:end -->

This specification provides a clear structure for the JSON format generated by `codb2json`, ensuring consistency and ease of processing.
